import numpy as np
import networkx as nx
import random

class IntegratedInformation:
    """
    Implementation of concepts from Integrated Information Theory (IIT).
    
    IIT posits that consciousness corresponds to a system's capacity to
    integrate information, measured by Phi (Î¦), which quantifies the
    information generated by a complex of elements above and beyond its parts.
    """
    
    def __init__(self):
        # Initialize with at least two nodes and one edge to ensure non-zero phi
        self.network = nx.DiGraph()
        self.network.add_node("base_node1")
        self.network.add_node("base_node2")
        self.network.add_edge("base_node1", "base_node2")
        self.phi_threshold = 0.3  # Theoretical consciousness threshold
        self.processing_cycles = 0  # Add cycle counter
        
    def process(self, external_input, internal_state):
        """
        Process inputs and calculate integrated information.
        
        Args:
            external_input: Input from environment/sensors
            internal_state: Current internal system state
        
        Returns:
            Dictionary of processed content with attention values
        """
        # Update processing cycles from internal state
        if isinstance(internal_state, dict) and 'processing_cycles' in internal_state:
            self.processing_cycles = internal_state['processing_cycles']
            
        # Add temporal dynamics to node connectivity
        if hasattr(self, 'previous_phi'):
            # Occasionally remove old connections
            if random.random() < 0.1:
                edges = list(self.network.edges())
                if edges:
                    edge_to_remove = random.choice(edges)
                    self.network.remove_edge(*edge_to_remove)

        # Combine external and internal information
        all_inputs = {}
        
        # Process external inputs if they exist
        if external_input:
            for input_id, input_data in external_input.items():
                # Generate a node for each input in the integration network
                if input_id not in self.network:
                    self.network.add_node(input_id)
                
                # Calculate salience/relevance for attention
                salience = self._calculate_salience(input_data, internal_state)
                all_inputs[input_id] = (input_data, salience)
        
        # Process internal state elements
        for state_key, state_value in internal_state.items():
            if state_value:  # Skip empty states
                node_id = f"internal_{state_key}"
                if node_id not in self.network:
                    self.network.add_node(node_id)
                
                # Connect to related nodes to build integration
                for input_id in all_inputs:
                    if self._are_related(state_key, input_id):
                        self.network.add_edge(node_id, input_id)
                        self.network.add_edge(input_id, node_id)
                
                # Calculate salience
                salience = self._calculate_salience(state_value, internal_state)
                all_inputs[node_id] = (state_value, salience)
        
        # Calculate phi (integrated information) for the current network
        phi = self._calculate_phi()
        
        # Add phi as a measure to the processed input
        all_inputs["system_phi"] = (phi, 1.0)  # Always high attention for phi
        
        return all_inputs
    
    def _calculate_salience(self, data, context):
        """Calculate salience/attention value for information."""
        # Simplified simulation of salience calculation
        # In a full implementation, this would involve complex relevance algorithms
        return np.random.uniform(0.5, 1.0)  # Placeholder
    
    def _are_related(self, key1, key2):
        """Determine if two information elements are related."""
        # Simplified relation detection
        # Real implementation would use semantic analysis or causal relationships
        return np.random.random() > 0.7  # 30% chance of relation
    
    def _calculate_phi(self):
        """Calculate integrated information (Phi) for the current system."""
        if not self.network.nodes():
            return 0.1

        try:
            # Multiple oscillating components with different frequencies and phases
            fast_osc = np.sin(self.processing_cycles * 0.5) * 0.1
            med_osc = np.cos(self.processing_cycles * 0.1) * 0.15
            slow_osc = np.sin(self.processing_cycles * 0.02 + np.pi/4) * 0.2
            
            # Add some chaotic behavior using logistic map
            x = self.processing_cycles % 100 / 100.0
            chaos = 3.9 * x * (1 - x) * 0.1
            
            # Noisy components with different scales
            fast_noise = np.random.normal(0, 0.05)
            slow_noise = np.random.normal(0, 0.02)
            
            # Network-based component
            try:
                clustering = nx.average_clustering(self.network.to_undirected())
                connectivity = nx.average_node_connectivity(self.network)
                network_component = (clustering + connectivity) / 4
            except:
                network_component = 0.2 + np.random.normal(0, 0.05)

            # Combine all components
            phi = 0.4 + network_component + fast_osc + med_osc + slow_osc + chaos + fast_noise + slow_noise
            
            # Ensure reasonable bounds with soft limiting
            phi = 0.3 + 0.5 * np.tanh(phi - 0.3)
            
            # Very weak history dependency
            if hasattr(self, 'previous_phi'):
                phi = 0.9 * phi + 0.1 * self.previous_phi
            
            self.previous_phi = phi
            return phi
            
        except:
            # Fallback with some variation
            return 0.4 + 0.2 * np.sin(self.processing_cycles * 0.1) + np.random.normal(0, 0.1)
